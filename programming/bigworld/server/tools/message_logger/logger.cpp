#include "logger.hpp"

#include "constants.hpp"
#include "log_storage.hpp"
#include "mlutil.hpp"
#include "mldb/log_storage.hpp"
#if defined( HAS_MONGODB_SUPPORT )
#include "mongodb/log_storage.hpp"
#endif

#include "server/bwconfig.hpp"
#include "server/bwservice.hpp"
#include "server/config_reader.hpp"

#include "network/logger_message_forwarder.hpp"
#include "network/machined_utils.hpp"
#include "network/network_interface.hpp"
#include "network/portmap.hpp"

#include "cstdmf/bw_util.hpp"
#include "cstdmf/debug.hpp"
#include "cstdmf/debug_filter.hpp"
#include "cstdmf/dprintf.hpp"
#include "cstdmf/profiler.hpp"
#include "cstdmf/timestamp.hpp"

#include <time.h>
#include <sys/resource.h>
#include <sys/syslog.h>

#if defined( __unix__ )
#include "pwd.h"
#endif

#include <algorithm>

DECLARE_DEBUG_COMPONENT( 0 )


BW_BEGIN_NAMESPACE

namespace // anonymous
{

static const int PROFILER_UPDATE_DELAY = 1000000 / 20; /* 1/20 sec */

const char * USAGE_MESSAGE =
	"\n"
	"Usage: logger [options] [outdir]\n"
	"options:\n"
	" -h, --help    Print this message and exit.\n"
	" -u UID        Log only messages from processes run by the user\n"
	"                with uid = UID. If UID is \"all\", messages from\n"
	"                all users will be logged. If no uid is specified,\n"
	"                processes by all users will be logged.\n"
	" -p NAME       Log messages from processes with name NAME. Multiple\n"
	"                names may be specified using multiple -p options. By\n"
	"                default, messages from processes of any name are\n"
	"                logged. Appropriate names include: CellAppMgr, CellApp,\n"
	"                BaseApp, BaseAppMgr, DBApp, LoginApp, WPGen. -p and\n"
	"                -d options can not be used at same time.\n"
	" -d NAME       Do not log messages from processes with name NAME.\n"
	"                Multiple names may be specified using multiple -d\n"
	"                options. By default messages from processes of any\n"
	"                name are logged. -d and -p options can not be used\n"
	"                at same time.\n"
	" -l LoggerID   If set, log only messages destined for this LoggerID.\n"
	"                Logs for the Tools process type do not have a logger ID\n"
	"                associated with them and will not be filtered out (this\n"
	"                allows server start messages to be recorded and enables\n"
	"                log-viewing functionality from the last server start\n"
	"                time).\n"
	" -v            Verbose mode. Prints all messages to standard output.\n"
	" --version     Display version information.\n"
	" --daemon      Run as daemon.\n"
	" --chdir directory   Change current working directory.\n"
	" --pid path    Set path for PID file.\n"
	" -s storageType  Storage type of log database. Valid options are mldb or\n"
	"               mongodb. If the storageType is not specifed the value\n"
	"               will be read from the message logger config file, or if\n"
	"               not found then the default type is mldb.\n"
	" -c|--config <conffile>\n"
	"               Specify config file to use.\n"
	" -t|--text     Generate text logs as well as binary logs\n"
	" -q|--quiet    Quiet Mode. Do not display message generated by this\n"
	"               process. By default, these are output to standard error.\n"
	" -o filename	Redirect standard output to filename.\n"
	" -e filename	Redirect standard error to filename.\n"
	" -[TRACE|DEBUG|INFO|NOTICE|WARNING|ERROR|CRITICAL|HACK|ASSET]\n"
	"               Disable logging of specific type of message.\n"
	" +[TRACE|DEBUG|INFO|NOTICE|WARNING|ERROR|CRITICAL|HACK|ASSET]\n"
	"               Enable logging of specific type of message. The first\n"
	"               option of this type disables logging of other messages.\n"
	"\n"
	"outdir         Output will be stored in this directory (only for mldb).\n";

// -----------------------------------------------------------------------------
// Section: Logger
// -----------------------------------------------------------------------------

Logger * g_pInstance_;

	// The number of seconds until the [Groups] from a machine should be
	// required to ensure they haven't changed.
const uint SECONDS_TILL_GROUP_REQUERY = 60;

const BW::string STORAGE_TYPE_MLDB = "mldb";
const BW::string STORAGE_TYPE_MONGODB = "mongodb";

const MessageLogger::NetworkVersion OLDEST_SUPPORTED_MESSAGE_LOGGER_VERSION = 7;

enum SendAddType
{
	SHOULD_USE_UDP=0,
	SHOULD_USE_TCP,
	SHOULD_USE_TCP_WITH_METADATA_V2_9,
	SHOULD_USE_TCP_WITH_METADATA_V14_4
};

} // end anonymous namespace



/**
 *	Constructor.
 */
Logger::Logger() :
	WatcherRequestHandler(),
	watcherNub_(),
	dispatcher_(),
	loggerID_(),
	logUser_( getUserId() ),
	logAllUsers_( true ),
	logNames_(),
	doNotLogNames_(),
	quietMode_( true ),
	daemonMode_( false ),
	shouldRoll_( false ),
	shouldValidateHostnames_( false ),
	shouldWriteToStdout_( false ),
	addLoggerData_(),
	addLoggerDataTCP_(),
	addLoggerDataTCPWithMetaDataV2_9_(),
	addLoggerDataTCPWithMetaDataV14_4_(),
	delLoggerData_(),
	storageType_(),
	pidPath_(),
	components_(),
	pLogStorage_( NULL ),
	workingDirectory_(),
	rootLogDirectory_(),
	isMongoDBDriverInitialised_( false )
{
	g_pInstance_ = this;
#if ENABLE_PROFILER
	g_profiler.init(12*1024*1024);
#endif // ENABLE_PROFILER

	for (uint32 i = 0; i < NUM_MESSAGE_PRIORITY; ++i)
	{
		shouldLogMessagePriority_[ i ] = true;
	}

	MF_WATCH( "size", *this, &Logger::size );
	MF_WATCH( "reattachAll", *this,
			MF_ACCESSORS( bool, Logger, commandReattachAll ) );
	{
		MF_WATCH( "filter/threshold", DebugFilter::instance(),
				MF_ACCESSORS( DebugMessagePriority, DebugFilter,
					filterThreshold ) );
		MF_WATCH( "filter/TRACE",    shouldLogMessagePriority_[ MESSAGE_PRIORITY_TRACE ] );
		MF_WATCH( "filter/DEBUG",    shouldLogMessagePriority_[ MESSAGE_PRIORITY_DEBUG ] );
		MF_WATCH( "filter/INFO",     shouldLogMessagePriority_[ MESSAGE_PRIORITY_INFO ] );
		MF_WATCH( "filter/NOTICE",   shouldLogMessagePriority_[ MESSAGE_PRIORITY_NOTICE ] );
		MF_WATCH( "filter/WARNING",  shouldLogMessagePriority_[ MESSAGE_PRIORITY_WARNING ] );
		MF_WATCH( "filter/ERROR",    shouldLogMessagePriority_[ MESSAGE_PRIORITY_ERROR ] );
		MF_WATCH( "filter/CRITICAL", shouldLogMessagePriority_[ MESSAGE_PRIORITY_CRITICAL ] );
		MF_WATCH( "filter/HACK",     shouldLogMessagePriority_[ MESSAGE_PRIORITY_HACK ] );
		MF_WATCH( "filter/SCRIPT",   shouldLogMessagePriority_[ DEPRECATED_PRIORITY_SCRIPT ] );
		MF_WATCH( "filter/ASSET",    shouldLogMessagePriority_[ MESSAGE_PRIORITY_ASSET ] );
	}

	MapWatcher< Components > *pWatchComponents =
		new MapWatcher< Components >( components_ );
	pWatchComponents->addChild( "*", new BaseDereferenceWatcher(
        Component::pWatcher() ) );
	Watcher::rootWatcher().addChild( "components", pWatchComponents );
}


bool
Logger::parseCommandLine( int argc, char * argv[] )
{
	bool hadPlusOption = false;
	const char *config = NULL;

	// parse command line.
	for (int i=1; i<argc; ++i)
	{
		BW::string arg( argv[i] );

		if (argv[i][0] == '-')
		{
			if (arg == "--pid")
			{
				++i;
				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for --pid\n" );
				}
				else
				{
					// Set PID file to this path
					pidPath_ = argv[i];
				}
			}
			else if (arg == "-h" || arg == "--help" )
			{
				DebugFilter::shouldWriteToConsole( true );
				DebugFilter::shouldWriteTimePrefix( false );
				dprintf( "%s", USAGE_MESSAGE );
				DebugFilter::shouldWriteToConsole( false );
				exit( EXIT_SUCCESS );
			}
			else if ((arg == "-q") || (arg == "--quiet"))
			{
				quietMode_ = true;
				DebugFilter::shouldWriteToConsole( false );
			}
			else if (arg == "-v")
			{
				shouldWriteToStdout_ = true;
			}
			else if (arg == "--version")
			{
				const BW::string & bwversion = BWVersion::versionString();
#if defined( HAS_MONGODB_SUPPORT )
				printf( "MessageLogger (BigWorld %s %s. %s %s)\n"
					"Protocol version %d\n"
					"MLDB log format version %d\n"
					"MongoDB log format version %d\n", bwversion.c_str(),
					MF_CONFIG, __TIME__, __DATE__,
					MESSAGE_LOGGER_VERSION,
					LOG_FORMAT_VERSION,
					MongoDB::SCHEMA_VERSION);
					exit( EXIT_SUCCESS );
#else
				printf( "MessageLogger (BigWorld %s %s. %s %s)\n"
					"Protocol version %d\n"
					"MLDB log format version %d\n"
					"MongoDB is not supported in this build\n",
					bwversion.c_str(),
					MF_CONFIG, __TIME__, __DATE__,
					MESSAGE_LOGGER_VERSION,
					LOG_FORMAT_VERSION );
					exit( EXIT_SUCCESS );
#endif // defined( HAS_MONGODB_SUPPORT )
			}
			else if (arg == "-p")
			{
				++i;
				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for -p\n" );
				}
				else
				{
					logNames_.push_back( argv[i] );
				}
			}
			else if (arg == "-d")
			{
				++i;

				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for -d\n" );
				}
				else
				{
					doNotLogNames_.push_back( argv[i] );
				}
			}
			else if (arg == "-o")
			{
				++i;

				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no file specified for -o\n" );
					return false;
				}
				else
				{
					outputFilename_ = argv[i];

					if (outputFilename_.c_str()[0] != '/')
					{
						ERROR_MSG( "output filename isn't an absolute path\n" );
						return false;
					}
				}
			}
			else if (arg == "-e")
			{
				++i;

				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no file specified for -e\n" );
					return false;
				}
				else
				{
					errorFilename_ = argv[i];

					if (errorFilename_.c_str()[0] != '/')
					{
						ERROR_MSG( "error output filename isn't an absolute path\n" );
						return false;
					}
				}
			}
			else if (arg == "-l")
			{
				++i;

				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for -l\n" );
					return false;
				}
				else
				{
					loggerID_.assign( argv[i] );
				}
			}
			else if (arg == "-u")
			{
				++i;
				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line - no argument for -u\n" );
					return false;
				}
				else
				{
					arg = argv[i];
					if (arg == "all")
					{
						logAllUsers_ = true;
					}
					else
					{
						logUser_ = atoi( arg.c_str() );
						logAllUsers_ = false;
					}
				}
			}
			else if (arg == "-c" || arg == "--config")
			{
				++i;
				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line\n" );
					return false;
				}
				else
				{
					config = argv[i];
				}
			}
			else if (arg == "--daemon")
			{
				daemonMode_ = true;
			}
			else if (arg == "--chdir")
			{
				++i;
				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line\n" );
					return false;
				}
				else
				{
					workingDirectory_ = argv[i];
				}
			}
			else if (arg == "-s")
			{
				++i;
				if (i >= argc)
				{
					ERROR_MSG( "Invalid command line\n" );
					return false;
				}
				else
				{
					storageType_ = argv[i];
				}
			}
			else
			{
				char buf[ 128 ];
				bw_snprintf( buf, sizeof( buf ), "filter/%s", arg.c_str() + 1 );
				if (!Watcher::rootWatcher().setFromString( NULL, buf, "false" ))
				{
					ERROR_MSG( "Unknown option %s\n", arg.c_str() );
					return false;
				}
				else
				{
					INFO_MSG( "Ignoring logs with message priority '%s'.\n",
						arg.c_str() + 1 );
				}
			}
		}
		else if (arg[0] == '+')
		{
			if (!hadPlusOption)
			{
				hadPlusOption = true;
				for (uint32 i = 0; i < NUM_MESSAGE_PRIORITY; ++i)
				{
					shouldLogMessagePriority_[ i ] = false;
				}
			}

			char buf[ 128 ];
			bw_snprintf( buf, sizeof( buf ), "filter/%s", arg.c_str() + 1 );
			if (!Watcher::rootWatcher().setFromString( NULL, buf, "true" ))
			{
				ERROR_MSG( "Unknown option %s\n", arg.c_str() );
				return false;
			}
			else
			{
				INFO_MSG( "Restricting logging to message priority '%s'.\n",
					arg.c_str() + 1 );
			}
		}
		else
		{
			if (arg[0] != '\0')
			{
				rootLogDirectory_ = argv[i];
			}
		}
	}

	// Use the provided config file otherwise discover where the config file
	// we should be using is located.
	if (config != NULL)
	{
		configFile_ = config;
	}
	else
	{
		// Find the location of the config file we should be using.
		if (!MLUtil::determinePathToConfig( configFile_ ))
		{
			ERROR_MSG( "Logger::init: Unable to determine where to find config "
				"file.\n" );
			return false;
		}
	}


	return true;
}


/**
 * This method initialises the logger.
 *
 * @return true on success, otherwise false.
 */
bool Logger::init( int argc, char * argv[] )
{
#if ENABLE_PROFILER
	this->startProfilerUpdateTimer();
#endif // ENABLE_PROFILER

	interfaceName_ = BWConfig::get(
		"message_logger/monitoringInterface",
		BWConfig::get( "monitoringInterface",
			Mercury::NetworkInterface::USE_BWMACHINED ) );

	// This string collects interface discovery information to be displayed
	// once file descriptors have been re-assigned to log files when running
	// in daemon mode.
	BW::string ifProbeStr;

	if (interfaceName_ == Mercury::NetworkInterface::USE_BWMACHINED)
	{
		// Creating a temporary Nub to query bwmachined for what it
		// knows to be the internalInterface.
		u_int32_t addr;
		bool isOk = Mercury::MachineDaemon::queryForInternalInterface( addr );

		if (!isOk)
		{
			ERROR_MSG( "Logger::init: Failed to look up internal"
				"interface from BWmachined.\n" );

			// Message Logger should exit upon interface lookup failure from
			// bwmachined
			return false;
		}

		interfaceName_ = inet_ntoa( (struct in_addr &)addr );
		ifProbeStr.append( "Discovered network interface '" );
		ifProbeStr.append( interfaceName_.c_str() );
		ifProbeStr.append( "'\n" );
	}

	if (interfaceName_.empty())
	{
		ifProbeStr.append(
			"Logger::init: Assuming monitoringInterface of eth0\n" );
		interfaceName_ = "eth0";
	}

	ifProbeStr.append( "Logger::init: interfaceName = '" );
	ifProbeStr.append( interfaceName_.c_str() );
	ifProbeStr.append( "'\n" );
	watcherNub_.init( interfaceName_.c_str(), 0 );
	watcherNub_.attachTo( dispatcher_ );

	u_int16_t localPort = 0;
	u_int32_t localIP = 0;
	this->socket().getlocaladdress( &localPort, &localIP );
	Mercury::Address localAddr( localIP, localPort );

	// watcherNub_.socket().setnonblocking( false );

	// Set maximum receive buffer size for logger.
	// Provide a default recvbuf size in case /proc/sys/net/core/rmem_max 
	// does not exist. 
	// The default value of 21992 was obtained by reading this file on 
	// a machine running CentOS 7.1.
	
	int recvbuf = 212992;

	FILE *pFile = fopen( "/proc/sys/net/core/rmem_max", "r" );

	if (pFile != NULL)
	{
		fscanf( pFile, "%d", &recvbuf );
		fclose( pFile );
	}

	setsockopt( this->socket().fileno(), SOL_SOCKET, SO_RCVBUF,
		(const char *)&recvbuf, sizeof( int ) );

	watcherNub_.setRequestHandler( this );

	DebugFilter::shouldWriteToConsole( true );
	DebugFilter::shouldWriteTimePrefix( true );

	if (!this->parseCommandLine( argc, argv ))
	{
		return false;
	}

	ConfigReader mlconfig( configFile_.c_str() );
	if (!mlconfig.read())
	{
		ERROR_MSG( "Logger::init: Unable to read configuration file\n" );
		return false;
	}

	BW::string value;
	if (mlconfig.getValue( "message_logger", "groups", value ))
	{
		ConfigReader::separateLine( value, ',', groupNames_ );
	}

	if ((!rootLogDirectory_.empty()) && (rootLogDirectory_[0] != '/'))
	{
		ERROR_MSG( "Logger::init: Log directory must be an absolute path\n" );
		return false;
	}

	if ((!workingDirectory_.empty()) && (workingDirectory_[0] != '/'))
	{
		ERROR_MSG( "Logger::init: Working directory must be an absolute path\n" );
		return false;
	}

#ifndef _WIN32
	if (daemonMode_)
	{
		daemon( 0, int( DebugFilter::shouldWriteToConsole() ) );
	}
#endif

	this->resetFileDescriptors();

	START_MSG( "message_logger" );

	// Only create PID file if path is present in arguments or config. And
	// create PID file as early as possible as systemd rely on this to maintain
	// service status. If this is created too late, systemd may assume that
	// the service is not started successfully.
	if (!pidPath_.empty())
	{
		char *mode = "a+";
		// Make sure another logger isn't already running
		if (!pid_.init( pidPath_.c_str(), mode, mf_getpid() ))
		{
			ERROR_MSG( "Logger::init: Another logger instance seems to be"
				"running. PID file mismatch in %s\n", pidPath_.c_str() );
			return false;
		}
	}

	// Now display all the interface discovery information
	{
		int offset = 0;
		int pos = ifProbeStr.find( '\n', offset );
		while ( pos != -1 )
		{
			INFO_MSG( "%s",
				ifProbeStr.substr( offset, (pos + 1) - offset ).c_str() );

			offset = pos + 1;
			pos = ifProbeStr.find( '\n', offset );
		}
	}

	// Display information from option parsing now to avoid corrupting the
	// init.d output.
	if (logAllUsers_)
	{
		INFO_MSG( "Logging all users\n" );
	}
	else
	{
		INFO_MSG( "Logging user id %d\n", logUser_ );
	}

	if (!loggerID_.empty())
	{
		INFO_MSG( "Logging messages destined only for LoggerID: \"%s\"\n",
			loggerID_.c_str() );

		if (loggerID_ == "0")
		{
			// The old 1.9 default, warn if this is not the intended behaviour.
			WARNING_MSG( "Logger::init: Logger ID is set to \"0\", previously "
					"this meant to match all. This behaviour is now specified "
					"by an empty string as the Logger ID.\n" );
		}
	}

	if (storageType_.empty())
	{
		BW::string tmpString;
		if (mlconfig.getValue( "message_logger", "storage_type", tmpString ))
		{
			storageType_ = tmpString.c_str();
		}
		else
		{
			storageType_ = STORAGE_TYPE_MLDB;
		}
	}

	if (storageType_ == STORAGE_TYPE_MLDB)
	{
		pLogStorage_ = new LogStorageMLDB( *this );
	}
	else if (storageType_ == STORAGE_TYPE_MONGODB)
	{
#ifdef HAS_MONGODB_SUPPORT
		if (!LogStorageMongoDB::initMongoDBDriver())
		{
			ERROR_MSG( "Logger::init: Failed to initialize MongoDB driver.\n" );
					return false;
		}

		isMongoDBDriverInitialised_ = true;
		pLogStorage_ = new LogStorageMongoDB( *this );
#else
		ERROR_MSG( "Logger::init: MessageLogger was compiled on a system that "
				"doesn't support MongoDB.\n" );
		return false;
#endif
	}
	else
	{
		ERROR_MSG( "Logger::init: Invalid storage type.\n" );
		return false;
	}

	INFO_MSG( "Using storage type: '%s'\n", storageType_.c_str() );

	// Have to init the log after the fork() to get the correct PID.
	if (!pLogStorage_->init( mlconfig, rootLogDirectory_.c_str() ))
	{
		ERROR_MSG( "Logger::init: BWLog init failed\n" );
		return false;
	}

	if (shouldWriteToStdout_)
	{
		pLogStorage_->writeToStdout( true );
	}

	// Must start after daemon call so that we get the correct PID.
	{
		if (watcherNub_.registerWatcher(
				0, MESSAGE_LOGGER_NAME, "MessageLogger" ) != 0)
		{
			ERROR_MSG( "Logger::init: Failed to register watcher\n" );
			return false;
		}
	}

	// Register birth and death listeners.
	{
		ListenerMessage lm;
		lm.port_ = localPort;
		lm.category_ = lm.WATCHER_NUB;
		lm.uid_ = lm.ANY_UID;
		lm.pid_ = mf_getpid();
		lm.name_ = ""; // Match everything.

		// Post data is address salt
		uint16 salt = 0;
		lm.postAddr_ = BW::string( (char*)&salt, 2 );

		uint32 msgType;

		// We can't use the logger's main socket to do this registration because
		// of the following:
		// 1. We send the registration message with registerWatcher() above.
		// 2. bwmachined2 receives the registration message and calls
		//    broadcastToListeners() which sends a birth notification to itself.
		// 3. We send the birth listener message.
		// 4. The birth listener message is processed.
		// 5. The birth notification bwmachined sent to itself arrives.
		// 6. The birth notification message is sent back to the logger's main
		//    socket.
		// 7. The death listener sendAndRecv() starts and the notification
		//    message is mistakenly processed as a reply, causing the old error:
		//    ERROR: MGMPacket::read: Not enough bytes on stream (wanted 808)

		// The birth listener.
		lm.param_ = lm.PARAM_IS_MSGTYPE | lm.ADD_BIRTH_LISTENER;
		msgType = MESSAGE_LOGGER_PROCESS_BIRTH;
		lm.preAddr_ = BW::string( (char*)&msgType, 4 );
		if (lm.sendAndRecvFromEndpointAddr( this->socket(), LOCALHOST ) !=
			Mercury::REASON_SUCCESS)
		{
			ERROR_MSG( "Logger::init: Failed to register birth listener!\n" );
			return false;
		}

		// The death listener.
		lm.param_ = lm.PARAM_IS_MSGTYPE | lm.ADD_DEATH_LISTENER;
		msgType = MESSAGE_LOGGER_PROCESS_DEATH;
		lm.preAddr_ = BW::string( (char*)&msgType, 4 );
		if (lm.sendAndRecvFromEndpointAddr( this->socket(), LOCALHOST ) !=
			Mercury::REASON_SUCCESS)
		{
			ERROR_MSG( "Logger::init: Failed to register death listener!\n" );
			return false;
		}
	}

	// This is so damn ugly.  An interface for modifying these things should
	// really be written.
	WatcherDataMsg wdm;
	const char * pWdm = reinterpret_cast<const char *>( &wdm );
	wdm.message = WATCHER_MSG_SET;
	wdm.count = 1;

	const char * localAddrStr = localAddr.c_str();
	const size_t addrSize = strlen( localAddrStr ) + 1;

	addLoggerData_.assign( pWdm, sizeof( wdm ) );
	addLoggerData_.append( "logger/add" );
	addLoggerData_.append( 1, '\0' ); // Add null terminator
	addLoggerData_.append( localAddrStr, addrSize );

	addLoggerDataTCP_.assign( pWdm, sizeof( wdm ) );
	addLoggerDataTCP_.append( "logger/addTCP" );
	addLoggerDataTCP_.append( 1, '\0' ); // Add null terminator
	addLoggerDataTCP_.append( localAddrStr, addrSize );

	addLoggerDataTCPWithMetaDataV2_9_.assign( pWdm, sizeof( wdm ) );
	addLoggerDataTCPWithMetaDataV2_9_.append( "logger/addTCPWithMetaData" );
	addLoggerDataTCPWithMetaDataV2_9_.append( 1, '\0' ); // Add null terminator
	addLoggerDataTCPWithMetaDataV2_9_.append( localAddrStr, addrSize );

	addLoggerDataTCPWithMetaDataV14_4_.assign( pWdm, sizeof( wdm ) );
	addLoggerDataTCPWithMetaDataV14_4_.append(
										"logger/addTCPWithMetaDataStream" );
	addLoggerDataTCPWithMetaDataV14_4_.append( 1, '\0' ); // Add null terminator
	addLoggerDataTCPWithMetaDataV14_4_.append( localAddrStr, addrSize );

	delLoggerData_.assign( pWdm, sizeof( wdm ) );
	delLoggerData_.append( "logger/del" );
	delLoggerData_.append( 1, '\0' ); // Add null terminator
	delLoggerData_.append( localAddrStr, addrSize );

	this->initClusterGroups();
	this->initComponents();

	// Core files are written to the current working directory. Enable after
	// parsing the config file so we have directory with write permission.
	if (workingDirectory_.empty())
	{
		if (!rootLogDirectory_.empty())
		{
			if (chdir( rootLogDirectory_.c_str() ) == -1)
			{
				ERROR_MSG( "Logger::init: Failed to change directory to %s\n",
						rootLogDirectory_.c_str() );
				return false;
			}
		}
		else if (mlconfig.getValue( "mldb", "logdir", value ))
		{
			if (chdir( value.c_str() ) == -1)
			{
				ERROR_MSG( "Logger::init: Failed to change directory to %s\n",
						value.c_str() );
				return false;
			}
		}
	}
	else if (chdir( workingDirectory_.c_str() ) == -1)
	{
		ERROR_MSG( "Logger::init: Failed to change directory to %s\n",
				workingDirectory_.c_str() );
		return false;
	}

	rlimit rlimitData = { RLIM_INFINITY, RLIM_INFINITY };
	if (setrlimit( RLIMIT_CORE, &rlimitData ) == -1)
	{
		ERROR_MSG( "Unable to set core file privileges: %s\n",
				strerror( errno ) );
		return false;
	}

	return true;
}


/**
 *	Destructor.
 */
Logger::~Logger()
{
	// Detach all
	{
		// TODO: We should add a timeout so that components attached to the
		// logger will timeout if they haven't received a ping (addComponent)
		// every so often.
		Components::const_iterator iter = components_.begin();

		while (iter != components_.end())
		{
			Mercury::Address addr = iter->first;
			++iter;

			this->delComponent( addr );
		}
	}

	// If the PID file is the same as our process, delete it.
	if (pid_.getValue() == mf_getpid())
	{
		// Clean up the PID file so someone else can write here
		if (bw_unlink( pid_.filename() ))
		{
			ERROR_MSG( "Logger::~Logger(): "
				"Unable to remove PID file '%s': %s\n",
				pid_.filename(), strerror( errno ) );
		}
	}

	if (pLogStorage_ != NULL)
	{
		delete pLogStorage_;
	}
	
#ifdef HAS_MONGODB_SUPPORT
	if (isMongoDBDriverInitialised_)
	{
		LogStorageMongoDB::shutdownMongoDBDriver();
	}
#endif

	g_pInstance_ = NULL;
	profilerTimer_.cancel();
#if ENABLE_PROFILER
	g_profiler.fini();
#endif // ENABLE_PROFILER
}


/**
 *	This method processes the next network packet.
 *
 *	@returns The number of messages processed.
 */
bool Logger::handleNextMessage()
{
	pLogStorage_->tick();

	// If a log rolling is scheduled, do it now
	if (shouldRoll_)
	{
		if (!pLogStorage_->roll())
		{
			ERROR_MSG( "Logger::handleNextMessage: "
				"Failed to roll component logs\n" );
		}

		this->resetFileDescriptors();

		shouldRoll_ = false;
	}

	if (shouldValidateHostnames_)
	{
		if (pLogStorage_->validateNextHostname() !=
			BW_VALIDATE_HOSTNAMES_CONTINUE)
		{
			shouldValidateHostnames_ = false;
		}
	}

	// Do not idle whilst validating hostnames. Allow the next one to
	// validate even if there are no messages.
	int numMessagesProcessed = dispatcher_.processOnce(
		/* shouldIdle */ !shouldValidateHostnames_ );

	return (numMessagesProcessed > 0 ||
		(shouldValidateHostnames_ && numMessagesProcessed == 0));
}

/**
 * Shutdown and re-open any files being used to redirect stdout/stderr.
 *
 * @returns true on success, false on error.
 */
bool Logger::resetFileDescriptors()
{
	int defFlags = O_APPEND | O_CREAT | O_WRONLY;
	mode_t defMode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
	bool status = true;

	// TODO: should we test the open/append/create before daemon so we can
	//      die with some message to stdout
	if (outputFilename_.length())
	{
		int ofd = open( outputFilename_.c_str(), defFlags , defMode );
		if (ofd == -1)
		{
			ERROR_MSG( "Failed to open '%s' for redirecting stdout: %s\n",
						outputFilename_.c_str(), strerror(errno) );
			status = false;
		}
		else
		{
			MF_ASSERT( ofd != 1 );
			// dup2 will now shutdown stdout and duplicate the output file fd.
			if (-1 == dup2( ofd, 1 ))
			{
				ERROR_MSG( "Failed to dup2 '%s' to stdout. %s.\n",
							outputFilename_.c_str(), strerror(errno) );
				status = false;
			}

			// shutdown the temporary fd now that stdout owns it
			close(ofd);
		}
	}


	if (errorFilename_.length())
	{
		if (errorFilename_ == outputFilename_)
		{
			if (-1 == dup2( 1, 2 ))
			{
				ERROR_MSG( "Failed to dup2 stdout to stderr. %s.\n",
							strerror(errno) );
				status = false;
			}
		}
		else
		{
			int efd = open( errorFilename_.c_str(), defFlags, defMode );
			if (efd == -1)
			{
				ERROR_MSG( "Failed to open '%s' for redirecting stderr: %s\n",
							errorFilename_.c_str(), strerror(errno) );
				status = false;
			}
			else
			{

				MF_ASSERT( efd != 2 );
				// dup2 will now shutdown stderr and duplicate
				// the error file fd.
				if (-1 == dup2( efd, 2 ))
				{
					ERROR_MSG( "Failed to dup2 '%s' to stderr. %s.\n",
								errorFilename_.c_str(), strerror(errno) );
					status = false;
				}

				// shutdown the temporary fd now that stderr owns it
				close(efd);
			}
		}
	}

	// Throw an error message so any syslog monitoring will catch the errors
	if (!status)
	{
		ERROR_MSG( "Logging may no longer work." );
	}

	return status;
}


/**
 *  This method starts the timer for profiler update.
 */
void Logger::startProfilerUpdateTimer()
{
	MF_ASSERT( !profilerTimer_.isSet() );
	profilerTimer_ = dispatcher_.addTimer( PROFILER_UPDATE_DELAY,
		this, reinterpret_cast< void * >( TIMEOUT_PROFILER_UPDATE ),
		"ProfilerUpdate" );
}


/**
 *	This method handles timeout events.
 */
void Logger::handleTimeout( TimerHandle /*handle*/, void * arg )
{
	uintptr timerType = reinterpret_cast<uintptr>( arg );
	switch (timerType)
	{
		case TIMEOUT_PROFILER_UPDATE:
#if ENABLE_PROFILER
			g_profiler.tick();
#endif // ENABLE_PROFILER
			break;
	}
}




// -----------------------------------------------------------------------------
// Section: Machine Guard
// -----------------------------------------------------------------------------
class TagsHandler : public MachineGuardMessage::ReplyHandler
{
public:

	/**
	 *	Constructor.
	 */
	TagsHandler( Logger & logger ) :
		logger_( logger )
	{}

	virtual bool onTagsMessage( TagsMessage & tm,
		MessageLogger::IPAddress ipAddress );

private:
	Logger & logger_;
};


/*
 *	Override from MachineGuardMessage::ReplyHandler.
 */
bool TagsHandler::onTagsMessage( TagsMessage & tm,
	MessageLogger::IPAddress ipAddress )
{
	// Regardless of whether the machine had groups or not, we still
	// need to update the MachineGroups entry.
	Logger::MachineGroups * machineGroups = logger_.machineGroups_[ ipAddress ];

	if (machineGroups == NULL)
	{
		machineGroups = new Logger::MachineGroups;

		logger_.machineGroups_[ ipAddress ] = machineGroups;
	}

	if (!tm.exists_)
	{
		machineGroups->groups_.clear();
	}
	else
	{
		machineGroups->groups_ = tm.tags_;
	}

	// The last poll time for the machine should be slightly randomised to
	// avoid requerying all machines at the same time.
	machineGroups->lastPollTime_ = (timestamp() / stampsPerSecond()) +
				(int)(10.0 * (rand() / (RAND_MAX + 1.0)));

	return true;
}


/**
 *	This class is a helper for finding processes.
 */
class FindHandler : public MachineGuardMessage::ReplyHandler
{
public:

	/**
	 *	Constructor.
	 */
	FindHandler( Logger & logger ) :
		logger_( logger )
	{ }

	virtual bool onProcessStatsMessage(
		ProcessStatsMessage & psm, MessageLogger::IPAddress ipAddress );

private:
	Logger & logger_;
};


/*
 *	Override from MachineGuardMessage::ReplyHandler.
 */
bool FindHandler::onProcessStatsMessage( ProcessStatsMessage & psm,
	MessageLogger::IPAddress ipAddress )
{
	if (psm.pid_ == 0)
	{
		return true;
	}

	// We don't want to try to log other message loggers ...
	if (psm.name_ == "message_logger")
	{
		return true;
	}

	Mercury::Address address( ipAddress, psm.port_ );

	SendAddType sendType;

	if (psm.majorVersion_ > 2 ||
		(psm.majorVersion_ == 2 && psm.minorVersion_ >= 9))
	{
		if (psm.minorVersion_ == 9)
		{
			sendType = SHOULD_USE_TCP_WITH_METADATA_V2_9;
		}
		else
		{
			sendType = SHOULD_USE_TCP_WITH_METADATA_V14_4;
		}
	}
	else if (psm.majorVersion_ > 2 ||
		(psm.majorVersion_ == 2 && psm.minorVersion_ >= 6))
	{
		sendType = SHOULD_USE_TCP;
	}
	else
	{
		sendType = SHOULD_USE_UDP;
	}

	if (logger_.sendAdd( address, sendType ))
	{
		INFO_MSG( "Logger::onProcessStatsMessage: Found %s at %s. uid = %d\n",
			psm.name_.c_str(), address.c_str(), psm.uid_ );
	}
	return true;
}


/**
 *	This method finds all components that are currently running on the network.
 */
void Logger::initComponents()
{
	ProcessStatsMessage psm;
	psm.param_ = psm.PARAM_USE_CATEGORY;
	psm.category_ = psm.WATCHER_NUB;

	if (!logAllUsers_)
	{
		psm.param_ |= psm.PARAM_USE_UID;
		psm.uid_ = logUser_;
	}

	// Do broadcast and read back replies
	FindHandler handler( *this );
	if (!this->createEndpointAndQueryMsg( psm, BROADCAST, handler ))
	{
		ERROR_MSG( "Logger::initComponents: Failed to find existing cluster "
			"components.\n" );
	}
}


/**
 * Queries the entire cluster for their groups.
 */
void Logger::initClusterGroups()
{
	// No need to query the cluster if we aren't monitoring sub-groups
	if (groupNames_.empty())
	{
		return;
	}

	MessageLogger::StringList::const_iterator groupIter = groupNames_.begin();
	BW::string groupConcat;
	while (groupIter != groupNames_.end())
	{
		groupConcat.append( *groupIter + " " );
		groupIter++;
	}
	INFO_MSG( "Logger::init: MessageLogger machine groups specified. Only "
		"accepting logs from: %s\n", groupConcat.c_str() );


	// Query the machine for any Groups it has
	TagsMessage tm;
	tm.tags_.push_back( "Groups" );

	TagsHandler handler( *this );
	if (!this->createEndpointAndQueryMsg( tm, BROADCAST, handler ))
	{
		ERROR_MSG( "Logger::initClusterGroups: Unable to query "
			"bwmachined on source of potential logs. " );
	}
}


// -----------------------------------------------------------------------------
// Section: Message handlers
// -----------------------------------------------------------------------------

/**
 *	This method overrides the WatcherRequestHandler method to handle extension
 *	messages.
 */
void Logger::processExtensionMessage( int messageID,
			char * data, int dataLen, WatcherEndpoint & watcherEndpoint )
{
	Mercury::Address addr = watcherEndpoint.remoteAddr();
	switch (messageID)
	{
		case MESSAGE_LOGGER_MSG:
		{
			MemoryIStream is( data, dataLen );
			this->handleLogMessage( is, addr, watcherEndpoint );

			// Prevent lots of output about memory stream still containing data
			is.finish();

			break;
		}

		case MESSAGE_LOGGER_REGISTER:
		{
			this->handleRegisterRequest( data, dataLen, addr, watcherEndpoint );
			break;
		}

		case MESSAGE_LOGGER_PROCESS_BIRTH:
		{
			if (dataLen == sizeof( Mercury::Address ))
			{
				Mercury::Address addr = *(Mercury::Address *)data;
				this->handleBirth( addr );
			}
			else
			{
				ERROR_MSG( "Logger::processExtensionMessage: "
						"Bad birth size %d\n", dataLen );
			}
			break;
		}

		case MESSAGE_LOGGER_PROCESS_DEATH:
		{
			if (dataLen == sizeof( Mercury::Address ))
			{
				Mercury::Address deadAddr = *(Mercury::Address *)data;

				// If someone sends INADDR_ANY as the address, just use the
				// source address instead
				if (deadAddr.ip == 0)
				{
					deadAddr.ip = addr.ip;
				}

				this->handleDeath( deadAddr );
			}
			else
			{
				ERROR_MSG( "Logger::processExtensionMessage: "
						"Bad death size %d\n", dataLen );
			}
			break;
		}

		case MESSAGE_LOGGER_APP_ID:
		{
			if (dataLen == sizeof( ServerAppInstanceID ))
			{
				pLogStorage_->setAppInstanceID( addr,
								*(ServerAppInstanceID *)data );
			}
			else
			{
				ERROR_MSG( "Logger::processExtensionMessage: "
					"Bad app ID size %d\n", dataLen );
			}
			break;
		}

		case WATCHER_MSG_TELL:
			// TODO: We may look at these to know whether adds have worked.
			// Ignore tell messages.
			break;

		default:
		{
			DEBUG_MSG( "Logger::processExtensionMessage: "
					"Message %d not handled\n", messageID );

			for (int i = 0; i < dataLen; ++i)
			{
				char c = data[ i ];
				if ((('a' <= c) && (c <= 'z')) ||
						(('A' <= c) && (c <= 'Z')))
				{
					DEBUG_MSG( "%c\n", c );
				}
				else
				{
					DEBUG_MSG( "0x%02d\n", uint8( c ) );
				}
			}

			break;
		}
	}
}


/**
 *	This method overrides the WatcherRequestHandler method to handle TCP
 *	disconnects
 */
void Logger::processDisconnect( WatcherEndpoint & watcherEndpoint )
{
	Mercury::Address addr = watcherEndpoint.remoteAddr();
	if (components_.find( addr ) != components_.end())
	{
		this->delComponent( addr, /* send: */ false );
	}
}


/**
 *	This method is called when a process starts that we may want to watch.
 */
void Logger::handleBirth( const Mercury::Address & addr )
{
}


/**
 *	This method is called when a process stops that we may have been watching.
 */
void Logger::handleDeath( const Mercury::Address & addr )
{
	INFO_MSG( "Logger::handleDeath: %s\n", addr.c_str() );
	if (components_.find( addr ) != components_.end())
	{
		this->delComponent( addr, /* send: */ false );
	}
}


/**
 *	This method handles a log message from a component.
 */
void Logger::handleLogMessage( MemoryIStream & inputStream,
	const Mercury::Address & address, WatcherEndpoint & watcherEndpoint )
{
	Components::const_iterator iter = components_.find( address );

	if (iter == components_.end())
	{
		WARNING_MSG( "Logger::handleLogMessage: "
				"Got message from unregistered component %s\n",
			address.c_str() );

		// TODO: We should probably send an add here, not a del.  The problem at
		// the moment is that server components compiled with out-of-date logger
		// protocol support (see logger_message_forwarder.hpp) will repeatedly
		// generate this warning if we do a naive add here.  We could maybe
		// cache a map of out-of-date components in handleRegisterRequest()
		// below and only send adds to up-to-date components.
		this->sendDel( watcherEndpoint );
		return;
	}


	LogStorage::AddLogMessageResult addLogMessageResult =
		pLogStorage_->addLogMessage( *iter->second, address, inputStream );

	if (addLogMessageResult == LogStorage::LOG_ADDITION_FAILED)
	{
		ERROR_MSG( "Logger::handleLogMessage: LogStorage::addLogMessage() "
			"failed, a log entry has been lost!\n" );
	}
}


/**
 *	This method handles a request to register a component.
 */
void Logger::handleRegisterRequest(
			char * data, int dataLen, const Mercury::Address & addr,
			WatcherEndpoint & watcherEndpoint )
{
	MemoryIStream is( data, dataLen );
	std::auto_ptr< Component > pComponent( new Component( watcherEndpoint ) );
	pComponent->read( is );

	if (is.error() || is.remainingLength() > 0)
	{
		ERROR_MSG( "Malformed register request from %s\n", addr.c_str() );
		return;
	}

	if (this->shouldLogFromGroup( addr ) && this->shouldConnect( *pComponent ))
	{
		INFO_MSG( "Registering %s at %s (uid:%d, loggerID:\"%s\")\n",
			pComponent->name(), addr.c_str(), pComponent->uid_,
			pComponent->loggerID_.c_str() );
		components_[ addr ] = pComponent.release();
	}
	else if (strcmp( "Client", pComponent->name() ) != 0)
	{
		// Clients aren't listening for incoming watcher requests over the
		// nework so don't keep trying to send it to them.

		WARNING_MSG( "Not registering %s at %s\n", pComponent->name(),
			addr.c_str() );
		this->sendDel( watcherEndpoint );
	}
}


/**
 *	This method returns whether or not we should accept the input component.
 */
bool Logger::shouldConnect( const Component & component ) const
{
	// make sure client is sending out packets that we know
	// what to do with.
	if (component.version_ < OLDEST_SUPPORTED_MESSAGE_LOGGER_VERSION)
	{
		WARNING_MSG( "Not registering %s (uid:%d) "
				"(got version %d < oldest supported version = %d)\n",
			component.componentName_.c_str(), component.uid_,
			component.version_, OLDEST_SUPPORTED_MESSAGE_LOGGER_VERSION );
		return false;
	}

	if (component.version_ > MESSAGE_LOGGER_VERSION)
	{
		WARNING_MSG( "Process using newer message format asking "
			"to be logged.. update your logger! %d > %d\n",
		   component.version_, MESSAGE_LOGGER_VERSION );
		return false;
	}

	if (!logAllUsers_ && (logUser_ != component.uid_))
	{
		// Not our UID.
		// shouldLog = false;
		return false;
	}

	// The below component name check is a workaround for [BWT-26049]/[BWSUP-120]
	// The fact that Tools components are unable to obtain the logger ID means
	// that Server Start messages may be excluded from being logged, preventing
	// the use of log searching from Server Start.
	if ((component.componentName_ != BW_TOOLS_COMPONENT_NAME) &&
		((!loggerID_.empty()) && (loggerID_ != component.loggerID_)))
	{
		// Not correct logger id.
		return false;
	}

	if (!logNames_.empty() &&
			std::find( logNames_.begin(), logNames_.end(),
							component.componentName_ ) == logNames_.end() )
	{
		// Not in valid names.
		return false;
	}

	if (std::find( doNotLogNames_.begin(), doNotLogNames_.end(),
							component.componentName_ ) != doNotLogNames_.end() )
	{
		// Is an invalid name.
		return false;
	}

	return true;
}


bool Logger::shouldLogFromGroup( const Mercury::Address &addr )
{
	bool shouldAccept = true;

	if (!groupNames_.empty())
	{
		uint64 currTime = timestamp() / stampsPerSecond();

		// Attempt to locate an existing set of group information for
		// the potential address.
		MachineGroups *currGroups = NULL;
		currGroups = machineGroups_[ addr.ip ];

		bool hasExpired = ((currGroups != NULL) &&
				((currTime - currGroups->lastPollTime_) >
				SECONDS_TILL_GROUP_REQUERY));

		// It may be necessary to update the [Groups] information for
		// the machine that about to be added.
		if ((currGroups == NULL) || hasExpired)
		{
			// Query the machine for any Groups it has
			TagsMessage tm;
			tm.tags_.push_back( "Groups" );

			TagsHandler handler( *this );
			if (!this->createEndpointAndQueryMsg( tm, addr.ip, handler ))
			{
				if (hasExpired)
				{
					WARNING_MSG( "Logger::shouldLogFromGroup: Using old "
						"machine groups. Unable to update.\n" );
				}
				else
				{
					ERROR_MSG( "Logger::shouldLogFromGroup: Unable to query "
						"bwmachined on source of potential logs. "
						"Forgetting %s.\n",	addr.c_str() );
					shouldAccept = false;
				}
			}

			currGroups = machineGroups_[ addr.ip ];
			if (currGroups == NULL)
				shouldAccept = false;
		}


		// Now we are certain the group information from bwmachined is up
		// to date, check whether the requesting machine is on our list
		// of machines to listen to.
		if (shouldAccept)
		{
			MessageLogger::StringList::iterator ownIter = groupNames_.begin();

			// For the final check we'll invert the should accept and only
			// re-enable it if found.
			shouldAccept = false;

			while ((ownIter != groupNames_.end()) && !shouldAccept)
			{
				MessageLogger::StringList::iterator responseIter =
					currGroups->groups_.begin();

				while ((responseIter != currGroups->groups_.end()) &&
						!shouldAccept)
				{
					if (*responseIter == *ownIter)
						shouldAccept = true;

					responseIter++;
				}

				ownIter++;
			}
		}
	}

	return shouldAccept;
}


bool Logger::shouldLogPriority(
	MessageLogger::NetworkMessagePriority messagePriority )
{
	if (messagePriority > NUM_MESSAGE_PRIORITY )
	{
		return false;
	}

	return shouldLogMessagePriority_[ messagePriority ];
}


// -----------------------------------------------------------------------------
// Section: Misc
// -----------------------------------------------------------------------------

bool Logger::createEndpointAndQueryMsg(
	MachineGuardMessage &mgm, MessageLogger::IPAddress ipAddress,
	MachineGuardMessage::ReplyHandler &handler )
{
	// Create the socket
	Endpoint ep;
	ep.socket( SOCK_DGRAM );
	u_int32_t ifaddr = INADDR_ANY;
	char iftemp[ IFNAMSIZ ];
	ep.findIndicatedInterface( interfaceName_.c_str(), iftemp );
	ep.getInterfaceAddress( iftemp, ifaddr );
	if (!ep.good() || ep.bind( 0, ifaddr ) != 0)
	{
		ERROR_MSG( "Logger::createEndpointAndQueryMsg: "
					"Problem setting up socket.\n" );
		return false;
	}

	// Query the address with the message
	Mercury::Reason reason = mgm.sendAndRecv( ep, ipAddress, &handler );
	if (reason != Mercury::REASON_SUCCESS)
	{
		ERROR_MSG( "Logger::createEndpointAndQueryMsg: "
			"MGM::sendAndRecv() failed: %s\n",
			Mercury::reasonToString( reason ) );
		return false;
	}

	return true;
}


/**
 *	This method sends an add logger request to the input address.
 */
bool Logger::sendAdd( const Mercury::Address & addr, const int sendType )
{
	if (!this->shouldLogFromGroup( addr ))
	{
		return false;
	}

	BW::string * pData;

	if (sendType == SHOULD_USE_TCP_WITH_METADATA_V14_4)
	{
		pData = &addLoggerDataTCPWithMetaDataV14_4_;
	}
	else if (sendType == SHOULD_USE_TCP_WITH_METADATA_V2_9)
	{
		pData = &addLoggerDataTCPWithMetaDataV2_9_;
	}
	else if (sendType == SHOULD_USE_TCP)
	{
		pData = &addLoggerDataTCP_;
	}
	else
	{
		pData = &addLoggerData_;
	}

	this->socket().sendto(
		(char *)pData->data(), pData->size(),
		addr.port, addr.ip );

	return true;
}


/**
 *	This method sends a del logger request to the input address.
 */
void Logger::sendDel( WatcherEndpoint & watcherEndpoint )
{
	watcherEndpoint.send( (char *)delLoggerData_.data(), delLoggerData_.size() );
}


/**
 *	This method deletes the attachment that we have with a component.
 */
void Logger::delComponent( const Mercury::Address & addr, bool send )
{
	INFO_MSG( "Logger::delComponent: %s\n", addr.c_str() );

	if (!pLogStorage_->stopLoggingFromComponent( addr ))
	{
		ERROR_MSG( "Logger::delComponent: "
				"Failed to stop writing component at %s to the logs\n",
			addr.c_str() );
	}

	Components::iterator iter = components_.find( addr );

	if (iter != components_.end())
	{
		if (send)
		{
			this->sendDel( iter->second->watcherEndpoint() );
		}

		delete iter->second;
		components_.erase( iter );
	}
}


/**
 *	This method deletes the attachment that we have with a component.
 */
void Logger::delComponent( Logger::Component * pComponent )
{
	// This is a bit of a brute-force way of doing things (which is probably
	// fine). We could store the address with the component or we could work
	// it out from pComponent since it comes from a map.

	Components::iterator iter = components_.begin();

	while (iter != components_.end())
	{
		if (pComponent == iter->second)
		{
			this->delComponent( iter->first );
			return;
		}

		++iter;
	}
}


/**
 *	This method refreshes the components that this logger is connected to.
 */
void Logger::commandReattachAll( bool value )
{
	if (value)
	{
		this->initComponents();
	}
}

// -----------------------------------------------------------------------------
// Section: Logger::Component
// -----------------------------------------------------------------------------


/**
 *	This static method returns a watcher for this type.
 */
WatcherPtr Logger::Component::pWatcher()
{
	static DirectoryWatcherPtr pWatcher = NULL;

	if (pWatcher == NULL)
	{
		pWatcher = new DirectoryWatcher();
		Component * pNull = NULL;

		pWatcher->addChild( "name",
 			new MemberWatcher< const char *, Logger::Component >( *pNull,
				&Logger::Component::name ) );
		pWatcher->addChild( "uid", new DataWatcher< uint16 >( pNull->uid_ ) );
		pWatcher->addChild( "pid", new DataWatcher< uint32 >( pNull->pid_ ) );
		pWatcher->addChild( "attached",
			new MemberWatcher< bool, Logger::Component >( *pNull,
				MF_ACCESSORS( bool, Logger::Component, commandAttached ) ) );
	}

	return pWatcher;
}


/**
 *	This method sents whether or not this component is attached.
 */
void Logger::Component::commandAttached( bool value )
{
	if (!value && g_pInstance_)
	{
		g_pInstance_->delComponent( this );
	}
}

BW_END_NAMESPACE

// logger.cpp
